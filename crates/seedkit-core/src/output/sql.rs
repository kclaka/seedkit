use std::io::Write;

use crate::error::{Result, SeedKitError};
use crate::generate::engine::GeneratedData;
use crate::generate::value::Value;
use crate::schema::types::{DatabaseSchema, DatabaseType};

/// Write generated data as SQL INSERT statements.
pub fn write_sql<W: Write>(
    writer: &mut W,
    data: &GeneratedData,
    schema: &DatabaseSchema,
) -> Result<()> {
    let db_type = &schema.database_type;

    // Header comment
    writeln!(writer, "-- Generated by SeedKit").map_err(|e| SeedKitError::Output {
        message: "writing header".to_string(),
        source: e,
    })?;
    writeln!(writer, "-- Database: {}", schema.database_name).map_err(|e| {
        SeedKitError::Output {
            message: "writing header".to_string(),
            source: e,
        }
    })?;
    writeln!(writer).map_err(|e| SeedKitError::Output {
        message: "writing newline".to_string(),
        source: e,
    })?;

    // Disable FK checks for MySQL
    if matches!(db_type, DatabaseType::MySQL) {
        writeln!(writer, "SET FOREIGN_KEY_CHECKS = 0;").map_err(|e| SeedKitError::Output {
            message: "writing FK disable".to_string(),
            source: e,
        })?;
        writeln!(writer).map_err(|e| SeedKitError::Output {
            message: "writing newline".to_string(),
            source: e,
        })?;
    }

    // Begin transaction for SQLite
    if matches!(db_type, DatabaseType::SQLite) {
        writeln!(writer, "BEGIN TRANSACTION;").map_err(|e| SeedKitError::Output {
            message: "writing BEGIN".to_string(),
            source: e,
        })?;
        writeln!(writer).map_err(|e| SeedKitError::Output {
            message: "writing newline".to_string(),
            source: e,
        })?;
    }

    // Generate INSERT statements per table
    for (table_name, rows) in &data.tables {
        if rows.is_empty() {
            continue;
        }

        writeln!(writer, "-- Table: {}", table_name).map_err(|e| SeedKitError::Output {
            message: format!("writing table header for {}", table_name),
            source: e,
        })?;

        // Get column order from the first row
        let columns: Vec<&String> = rows[0].keys().collect();

        if columns.is_empty() {
            continue;
        }

        // Use batched INSERT for efficiency (multi-row VALUES)
        let batch_size = 100;
        for chunk in rows.chunks(batch_size) {
            let quoted_columns: Vec<String> = columns
                .iter()
                .map(|c| quote_identifier(c, db_type))
                .collect();

            writeln!(
                writer,
                "INSERT INTO {} ({}) VALUES",
                quote_identifier(table_name, db_type),
                quoted_columns.join(", ")
            )
            .map_err(|e| SeedKitError::Output {
                message: format!("writing INSERT for {}", table_name),
                source: e,
            })?;

            for (i, row) in chunk.iter().enumerate() {
                let values: Vec<String> = columns
                    .iter()
                    .map(|col| {
                        row.get(*col)
                            .map(|v| v.to_sql_literal(db_type))
                            .unwrap_or_else(|| "NULL".to_string())
                    })
                    .collect();

                let separator = if i == chunk.len() - 1 { ";" } else { "," };
                writeln!(writer, "  ({}){}", values.join(", "), separator).map_err(|e| {
                    SeedKitError::Output {
                        message: format!("writing row for {}", table_name),
                        source: e,
                    }
                })?;
            }

            writeln!(writer).map_err(|e| SeedKitError::Output {
                message: "writing newline".to_string(),
                source: e,
            })?;
        }
    }

    // Deferred FK updates (cycle resolution)
    if !data.deferred_updates.is_empty() {
        writeln!(writer, "-- Deferred foreign key updates (cycle resolution)").map_err(|e| {
            SeedKitError::Output {
                message: "writing deferred header".to_string(),
                source: e,
            }
        })?;

        for update in &data.deferred_updates {
            if let Some(sql) = build_deferred_update_sql(update, data, schema) {
                writeln!(writer, "{};", sql).map_err(|e| SeedKitError::Output {
                    message: "writing deferred update".to_string(),
                    source: e,
                })?;
            }
        }
        writeln!(writer).map_err(|e| SeedKitError::Output {
            message: "writing newline".to_string(),
            source: e,
        })?;
    }

    // End transaction for SQLite
    if matches!(db_type, DatabaseType::SQLite) {
        writeln!(writer, "COMMIT;").map_err(|e| SeedKitError::Output {
            message: "writing COMMIT".to_string(),
            source: e,
        })?;
    }

    // Re-enable FK checks for MySQL
    if matches!(db_type, DatabaseType::MySQL) {
        writeln!(writer, "SET FOREIGN_KEY_CHECKS = 1;").map_err(|e| SeedKitError::Output {
            message: "writing FK enable".to_string(),
            source: e,
        })?;
    }

    Ok(())
}

/// Write generated data using PostgreSQL COPY format for fast bulk loading.
pub fn write_postgres_copy<W: Write>(
    writer: &mut W,
    data: &GeneratedData,
    schema: &DatabaseSchema,
) -> Result<()> {
    let db_type = &schema.database_type;

    writeln!(writer, "-- Generated by SeedKit (PostgreSQL COPY format)").map_err(|e| {
        SeedKitError::Output {
            message: "writing header".to_string(),
            source: e,
        }
    })?;
    writeln!(writer).map_err(|e| SeedKitError::Output {
        message: "writing newline".to_string(),
        source: e,
    })?;

    for (table_name, rows) in &data.tables {
        if rows.is_empty() {
            continue;
        }

        let columns: Vec<&String> = rows[0].keys().collect();
        let quoted_columns: Vec<String> = columns
            .iter()
            .map(|c| quote_identifier(c, db_type))
            .collect();

        writeln!(
            writer,
            "COPY {} ({}) FROM stdin;",
            quote_identifier(table_name, db_type),
            quoted_columns.join(", ")
        )
        .map_err(|e| SeedKitError::Output {
            message: format!("writing COPY for {}", table_name),
            source: e,
        })?;

        for row in rows {
            let values: Vec<String> = columns
                .iter()
                .map(|col| {
                    row.get(*col)
                        .map(value_to_copy_format)
                        .unwrap_or_else(|| "\\N".to_string())
                })
                .collect();

            writeln!(writer, "{}", values.join("\t")).map_err(|e| SeedKitError::Output {
                message: format!("writing COPY data for {}", table_name),
                source: e,
            })?;
        }

        writeln!(writer, "\\.").map_err(|e| SeedKitError::Output {
            message: format!("writing COPY terminator for {}", table_name),
            source: e,
        })?;
        writeln!(writer).map_err(|e| SeedKitError::Output {
            message: "writing newline".to_string(),
            source: e,
        })?;
    }

    Ok(())
}

/// Convert a Value to PostgreSQL COPY format (tab-separated).
fn value_to_copy_format(value: &Value) -> String {
    match value {
        Value::Null => "\\N".to_string(),
        Value::Bool(b) => {
            if *b {
                "t".to_string()
            } else {
                "f".to_string()
            }
        }
        Value::Int(i) => i.to_string(),
        Value::Float(f) => f.to_string(),
        Value::String(s) => s
            .replace('\\', "\\\\")
            .replace('\t', "\\t")
            .replace('\n', "\\n"),
        Value::Timestamp(ts) => ts.format("%Y-%m-%d %H:%M:%S").to_string(),
        Value::Date(d) => d.format("%Y-%m-%d").to_string(),
        Value::Time(t) => t.format("%H:%M:%S").to_string(),
        Value::Uuid(u) => u.to_string(),
        Value::Json(j) => j.to_string().replace('\\', "\\\\").replace('\t', "\\t"),
        Value::Bytes(b) => format!(
            "\\\\x{}",
            b.iter()
                .map(|byte| format!("{:02x}", byte))
                .collect::<String>()
        ),
    }
}

/// Build a real UPDATE statement for a deferred FK update by looking up
/// the primary key value from the generated data.
fn build_deferred_update_sql(
    update: &crate::generate::engine::DeferredUpdate,
    data: &GeneratedData,
    schema: &DatabaseSchema,
) -> Option<String> {
    let db_type = &schema.database_type;
    let table = schema.tables.get(&update.table_name)?;
    let pk = table.primary_key.as_ref()?;
    let rows = data.tables.get(&update.table_name)?;
    let row = rows.get(update.row_index)?;

    let mut where_parts = Vec::new();
    for pk_col in &pk.columns {
        if let Some(pk_val) = row.get(pk_col) {
            where_parts.push(format!(
                "{} = {}",
                quote_identifier(pk_col, db_type),
                pk_val.to_sql_literal(db_type),
            ));
        } else {
            // Auto-increment PK not in the generated row — use synthesized ID
            let id = update.row_index as i64 + 1;
            where_parts.push(format!("{} = {}", quote_identifier(pk_col, db_type), id,));
        }
    }

    if where_parts.is_empty() {
        return None;
    }

    Some(format!(
        "UPDATE {} SET {} = {} WHERE {}",
        quote_identifier(&update.table_name, db_type),
        quote_identifier(&update.column_name, db_type),
        update.value.to_sql_literal(db_type),
        where_parts.join(" AND "),
    ))
}

/// Quote a SQL identifier based on database type.
fn quote_identifier(name: &str, db_type: &DatabaseType) -> String {
    match db_type {
        DatabaseType::MySQL => format!("`{}`", name),
        _ => format!("\"{}\"", name),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use indexmap::IndexMap;
    use std::borrow::Cow;

    #[test]
    fn test_write_sql_basic() {
        let mut tables = IndexMap::new();
        let mut row = IndexMap::new();
        row.insert(
            "name".to_string(),
            Value::String(Cow::Owned("Alice".to_string())),
        );
        row.insert("age".to_string(), Value::Int(30));
        tables.insert("users".to_string(), vec![row]);

        let data = GeneratedData {
            tables,
            deferred_updates: Vec::new(),
        };

        let schema = DatabaseSchema::new(DatabaseType::PostgreSQL, "test".to_string());
        let mut output = Vec::new();
        write_sql(&mut output, &data, &schema).unwrap();

        let sql = String::from_utf8(output).unwrap();
        assert!(sql.contains("INSERT INTO"));
        assert!(sql.contains("'Alice'"));
        assert!(sql.contains("30"));
    }

    #[test]
    fn test_quote_identifier() {
        assert_eq!(
            quote_identifier("users", &DatabaseType::PostgreSQL),
            "\"users\""
        );
        assert_eq!(quote_identifier("users", &DatabaseType::MySQL), "`users`");
    }

    #[test]
    fn test_deferred_updates_produce_real_sql() {
        use crate::generate::engine::DeferredUpdate;
        use crate::schema::types::*;

        let mut tables = IndexMap::new();
        let mut row = IndexMap::new();
        row.insert("id".to_string(), Value::Int(1));
        row.insert(
            "name".to_string(),
            Value::String(Cow::Owned("Alice".to_string())),
        );
        row.insert("invited_by_id".to_string(), Value::Null);
        tables.insert("users".to_string(), vec![row]);

        let data = GeneratedData {
            tables,
            deferred_updates: vec![DeferredUpdate {
                table_name: "users".to_string(),
                row_index: 0,
                column_name: "invited_by_id".to_string(),
                value: Value::Int(1),
            }],
        };

        let mut schema = DatabaseSchema::new(DatabaseType::PostgreSQL, "test".to_string());
        let mut users = Table::new("users".to_string());
        users.primary_key = Some(PrimaryKey {
            columns: vec!["id".to_string()],
            name: None,
        });
        schema.tables.insert("users".to_string(), users);

        let mut output = Vec::new();
        write_sql(&mut output, &data, &schema).unwrap();

        let sql = String::from_utf8(output).unwrap();
        assert!(
            sql.contains("UPDATE \"users\" SET \"invited_by_id\" = 1 WHERE \"id\" = 1;"),
            "Deferred updates must produce real UPDATE SQL, got:\n{}",
            sql
        );
        assert!(
            !sql.contains("-- UPDATE"),
            "Deferred updates should not be comments anymore"
        );
    }

    #[test]
    fn test_deferred_updates_auto_increment_pk() {
        use crate::generate::engine::DeferredUpdate;
        use crate::schema::types::*;

        // Row does NOT contain the PK (auto-increment, skipped during generation)
        let mut tables = IndexMap::new();
        let mut row = IndexMap::new();
        row.insert(
            "name".to_string(),
            Value::String(Cow::Owned("Bob".to_string())),
        );
        row.insert("parent_id".to_string(), Value::Null);
        tables.insert("categories".to_string(), vec![row]);

        let data = GeneratedData {
            tables,
            deferred_updates: vec![DeferredUpdate {
                table_name: "categories".to_string(),
                row_index: 0,
                column_name: "parent_id".to_string(),
                value: Value::Int(1),
            }],
        };

        let mut schema = DatabaseSchema::new(DatabaseType::PostgreSQL, "test".to_string());
        let mut table = Table::new("categories".to_string());
        table.primary_key = Some(PrimaryKey {
            columns: vec!["id".to_string()],
            name: None,
        });
        schema.tables.insert("categories".to_string(), table);

        let mut output = Vec::new();
        write_sql(&mut output, &data, &schema).unwrap();

        let sql = String::from_utf8(output).unwrap();
        // Auto-increment PK: row_index 0 → synthesized ID = 1
        assert!(
            sql.contains("UPDATE \"categories\" SET \"parent_id\" = 1 WHERE \"id\" = 1;"),
            "Should use synthesized auto-increment PK, got:\n{}",
            sql
        );
    }
}
