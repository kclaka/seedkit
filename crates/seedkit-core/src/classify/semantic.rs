use serde::{Deserialize, Serialize};
use std::fmt;

/// Semantic type classification for a database column.
/// Each variant maps to a specific data generation strategy.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum SemanticType {
    // === Identity ===
    FirstName,
    LastName,
    FullName,
    Username,
    DisplayName,

    // === Contact ===
    Email,
    Phone,
    PhoneCountryCode,

    // === Address ===
    StreetAddress,
    City,
    State,
    ZipCode,
    PostalCode,
    Country,
    CountryCode,
    Latitude,
    Longitude,

    // === Company ===
    CompanyName,
    JobTitle,
    Department,
    Industry,

    // === Internet ===
    Url,
    DomainName,
    IpAddress,
    MacAddress,
    UserAgent,
    Slug,

    // === Content ===
    Title,
    Description,
    Bio,
    Paragraph,
    Sentence,
    HtmlContent,
    MarkdownContent,

    // === Media ===
    ImageUrl,
    AvatarUrl,
    ThumbnailUrl,
    FileUrl,
    FileName,
    MimeType,
    FileSize,

    // === Financial ===
    Price,
    Currency,
    CurrencyCode,
    Amount,
    Percentage,

    // === Temporal ===
    CreatedAt,
    UpdatedAt,
    DeletedAt,
    StartDate,
    EndDate,
    BirthDate,
    DateOnly,
    TimeOnly,
    Timestamp,

    // === Auth/Security ===
    PasswordHash,
    Token,
    ApiKey,
    SecretKey,

    // === Identifiers ===
    Uuid,
    AutoIncrement,
    ExternalId,
    Sku,
    OrderNumber,
    InvoiceNumber,
    TrackingNumber,

    // === Status/Enum ===
    Status,
    Role,
    Priority,
    Category,
    Tag,
    BooleanFlag,
    EnumValue,

    // === Numeric ===
    Quantity,
    Rating,
    Score,
    Weight,
    Height,
    Age,
    Duration,
    SortOrder,

    // === Data ===
    JsonData,
    Color,
    HexColor,
    Locale,
    Timezone,

    // === Catch-all ===
    Unknown,
}

impl SemanticType {
    /// Returns true if this type is typically auto-generated by the database
    /// and should be skipped during data generation.
    pub fn is_auto_generated(&self) -> bool {
        matches!(self, SemanticType::AutoIncrement)
    }

    /// Returns true if this type should never contain real PII.
    pub fn is_pii(&self) -> bool {
        matches!(
            self,
            SemanticType::FirstName
                | SemanticType::LastName
                | SemanticType::FullName
                | SemanticType::Email
                | SemanticType::Phone
                | SemanticType::StreetAddress
                | SemanticType::BirthDate
                | SemanticType::PasswordHash
                | SemanticType::Token
                | SemanticType::ApiKey
                | SemanticType::SecretKey
                | SemanticType::IpAddress
        )
    }

    /// Returns the correlation group this type belongs to, if any.
    pub fn correlation_group(&self) -> Option<CorrelationGroup> {
        match self {
            SemanticType::StreetAddress
            | SemanticType::City
            | SemanticType::State
            | SemanticType::ZipCode
            | SemanticType::PostalCode
            | SemanticType::Country
            | SemanticType::CountryCode => Some(CorrelationGroup::Address),

            SemanticType::Latitude | SemanticType::Longitude => {
                Some(CorrelationGroup::GeoCoordinates)
            }

            SemanticType::FirstName
            | SemanticType::LastName
            | SemanticType::FullName
            | SemanticType::Email
            | SemanticType::Username => Some(CorrelationGroup::PersonIdentity),

            SemanticType::CreatedAt | SemanticType::UpdatedAt | SemanticType::DeletedAt => {
                Some(CorrelationGroup::Temporal)
            }

            SemanticType::StartDate | SemanticType::EndDate => {
                Some(CorrelationGroup::TemporalRange)
            }

            _ => None,
        }
    }
}

impl fmt::Display for SemanticType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}

/// Groups of columns that must be generated together to maintain consistency.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum CorrelationGroup {
    /// Street, city, state, zip, country should be geographically consistent
    Address,
    /// Latitude/longitude should be realistic coordinates
    GeoCoordinates,
    /// First name, last name, email, username should be derived from same identity
    PersonIdentity,
    /// created_at <= updated_at <= deleted_at
    Temporal,
    /// start_date < end_date
    TemporalRange,
}

impl fmt::Display for CorrelationGroup {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            CorrelationGroup::Address => write!(f, "Address"),
            CorrelationGroup::GeoCoordinates => write!(f, "GeoCoordinates"),
            CorrelationGroup::PersonIdentity => write!(f, "PersonIdentity"),
            CorrelationGroup::Temporal => write!(f, "Temporal"),
            CorrelationGroup::TemporalRange => write!(f, "TemporalRange"),
        }
    }
}
